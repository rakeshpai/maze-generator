{"version":3,"sources":["generator/types.ts","generator/helpers.ts","generator/index.ts","hooks/useMaze.ts","components/Cell.tsx","components/Maze.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["locations","range","max","Array","fill","map","unused","index","inc","x","dec","id","neighboursDefinition","matchingCell","y","cell","wallLens","location","Lens","fromPath","wallLenses","top","right","bottom","left","cellLens","maze","cells","find","Object","objectSpread","c","currentCellLens","fromProp","visitedLens","initializeMaze","width","height","populator","reduce","acc","concat","populateList","walls","visited","stack","currentCell","hasUnvisitedCells","some","unvisitedNeighboursForCurrentCell","_ref","_ref2","slicedToArray","xOp","yOp","cellAt","neighboursOfCurrentCell","filter","removeCellWall","compose","set","removeWallBetweenCurrentCellAnd","apply","toConsumableArray","get","tempMaze","indexOf","length","isCurrent","_currentCellLens$get","_currentCellLens$get2","makeMazePass","list","neighbours","randomNeighbour","Math","floor","random","m1","pushCurrentCellToStack","m2","m3","markCellAsVisited","slice","popFromStackToCurrentCell","useMaze","animated","timeout","_useState","useState","undefined","_useState2","setMaze","_useState3","_useState4","done","setDone","useEffect","callback","interval","setInterval","clearInterval","generateMazeStream","m","d","incx","incy","cellCoords","x1","y1","x2","y2","Cell","props","react_default","a","createElement","cellWidth","cellHeight","entries","_ref3","key","fn","defineProperty","startsWith","coords","assign","stroke","strokeWidth","cellLines","Maze","_ref$width","_ref$height","_ref$cellWidth","_ref$cellHeight","_useMaze","_useMaze2","components_Cell","App","components_Maze","Boolean","window","hostname","match","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.150ac9cc.chunk.js","sourcesContent":["export const locations = ['top', 'right', 'bottom', 'left'] as const;\nexport type Location = typeof locations[number];\n\nexport type Cell = {\n  x: number,\n  y: number,\n  walls: { [key in Location]: boolean },\n  visited: boolean\n};\n\nexport type CellCoords = [number, number];\n\nexport type Maze = {\n  width: number,\n  height: number,\n  cells: Cell[],\n  stack: CellCoords[],\n  currentCell: CellCoords\n};\n\nexport type CellWithLocation = Cell & { location: Location };\n","import { Lens } from 'monocle-ts';\nimport { Cell, Maze, locations, Location, CellWithLocation } from './types';\n\n// Local helpers\nconst range = (max: number) =>\n  (new Array(max)).fill(0).map((unused, index) => index);\n\nconst populateList = <T>(\n  width: number, height: number, populator: (x: number, y: number) => T\n): T[] => range(width).reduce<T[]>(\n  (acc, x) => acc.concat(range(height).map(y => populator(x, y))),\n  []\n);\n\nconst inc = (x: number) => x + 1;\nconst dec = (x: number) => x - 1;\nconst id = <T>(x: T) => x;\n\nexport const pickRandomlyFromList = <T>(list: T[]) =>\n  list[Math.floor(Math.random() * list.length)];\n\nexport const oppositeLocation = (location: Location) =>\n  locations[(locations.indexOf(location) + 2) % locations.length];\n\nconst neighboursDefinition: [Location, (x: number) => number, (y: number) => number][] = [\n  ['top', dec, id],\n  ['left', id, dec],\n  ['right', id, inc],\n  ['bottom', inc, id]\n];\n\nconst matchingCell = (x: number, y: number) => (cell: Cell) =>\n  cell.x === x && cell.y === y;\n\n// Lenses\nconst wallLens = (location: Location) => Lens.fromPath<Cell>()(['walls', location]);\n\nconst wallLenses: { [key in Location]: Lens<Cell, boolean> } = {\n  top: wallLens('top'),\n  right: wallLens('right'),\n  bottom: wallLens('bottom'),\n  left: wallLens('left')\n}\n\nconst cellLens = (x: number, y: number) => new Lens<Maze, Cell>(\n  maze => maze.cells.find(matchingCell(x, y))!,\n  cell => maze => ({\n    ...maze,\n    cells: maze.cells.map(c => matchingCell(x, y)(c) ? cell : c)\n  })\n);\n\nconst currentCellLens = Lens.fromProp<Maze>()('currentCell');\nconst visitedLens = Lens.fromProp<Cell>()('visited');\n\n// Maze helpers\nexport const initializeMaze = (width: number, height: number): Maze => {\n  const cells = populateList(width, height, (x, y): Cell => ({\n    x, y,\n    walls: { top: true, right: true, bottom: true, left: true},\n    visited: false\n  }));\n\n  return {\n    width, height, cells,\n    stack: [], currentCell: [ cells[0].x, cells[0].y ]\n  };\n};\n\nexport const hasUnvisitedCells = (maze: Maze) =>\n  maze.cells.some(cell => !cell.visited);\n\nexport const pushCurrentCellToStack = (maze: Maze) =>\n  ({ ...maze, stack: [ maze.currentCell, ...maze.stack ]})\n  \nexport const popFromStackToCurrentCell = (maze: Maze) =>\n  ({ ...maze, stack: maze.stack.slice(1), currentCell: maze.stack[0] });\n\nconst cellAt = (maze: Maze, x: number, y: number) => {\n  if(x < 0 || x > maze.height - 1 || y < 0 || y > maze.width - 1) {\n    return undefined;\n  }\n\n  return maze.cells[ (maze.width * x) + y ];\n};\n\nexport const setCurrentCell = (x: number, y: number) =>\n  currentCellLens.set([x, y]);\n\nexport const markCellAsVisited = (x: number, y: number) =>\n  cellLens(x, y).compose(visitedLens).set(true);\n\nconst neighboursOfCurrentCell = (maze: Maze) =>\n  neighboursDefinition.reduce<CellWithLocation[]>(\n    (acc, [location, xOp, yOp]) => {\n      const cell = cellAt(maze, xOp(maze.currentCell[0]), yOp(maze.currentCell[1]));\n      if(!cell) return acc;\n\n      return acc.concat({ ...cell, location })\n    },\n    []\n  );\n\nexport const unvisitedNeighboursForCurrentCell = (maze: Maze) =>\n  neighboursOfCurrentCell(maze)\n    .filter((cell: CellWithLocation) => !cell.visited);\n\nconst removeCellWall = (cell: Cell, location: Location) =>\n  cellLens(cell.x, cell.y).compose(wallLenses[location]).set(false);\n\nexport const removeWallBetweenCurrentCellAnd = (cell: CellWithLocation) => (maze: Maze): Maze => {\n  const currentCell = cellLens(...maze.currentCell).get(maze);\n\n  const tempMaze = removeCellWall(currentCell, cell.location)(maze);\n  return removeCellWall(cell, oppositeLocation(cell.location))(tempMaze);\n};\n\nexport const isCurrent = (cell: Cell) => (maze: Maze) => {\n  const [x, y] = currentCellLens.get(maze)\n  return cell.x === x && cell.y === y;\n};\n","import { Maze } from \"./types\";\nimport { unvisitedNeighboursForCurrentCell, pickRandomlyFromList, pushCurrentCellToStack, removeWallBetweenCurrentCellAnd, setCurrentCell, markCellAsVisited, popFromStackToCurrentCell, initializeMaze, hasUnvisitedCells } from \"./helpers\";\n\ntype MazeDimensions = { width: number, height: number };\ntype MazeStreamArguments = MazeDimensions & {\n  timeout: number,\n  callback: (maze: Maze, done: boolean) => void\n};\n\nconst makeMazePass = (maze: Maze) => {\n  const neighbours = unvisitedNeighboursForCurrentCell(maze);\n  \n  if(neighbours.length) {\n    const randomNeighbour = pickRandomlyFromList(neighbours);\n    const m1 = pushCurrentCellToStack(maze);\n    const m2 = removeWallBetweenCurrentCellAnd(randomNeighbour)(m1);\n    const m3 = setCurrentCell(randomNeighbour.x, randomNeighbour.y)(m2);\n    return markCellAsVisited(randomNeighbour.x, randomNeighbour.y)(m3);\n  }\n\n  if(maze.stack.length) {\n    return popFromStackToCurrentCell(maze);\n  }\n\n  return maze;\n}\n\nexport const generateMaze = ({ width, height }: MazeDimensions) => {\n  let maze = initializeMaze(width, height);\n  while(hasUnvisitedCells(maze)) {\n    maze = makeMazePass(maze);\n  }\n\n  return maze;\n};\n\nexport const generateMazeStream = ({ width, height, timeout, callback }: MazeStreamArguments) => {\n  let maze = initializeMaze(width, height);\n  callback(maze, !hasUnvisitedCells(maze));\n\n  const interval = setInterval(() => {\n    if(hasUnvisitedCells(maze)) {\n      maze = makeMazePass(maze);\n      callback(maze, !hasUnvisitedCells(maze));\n    } else {\n      clearInterval(interval);\n    }\n  }, timeout);\n\n  return () => clearInterval(interval);\n};\n","import { useState, useEffect } from \"react\";\nimport { generateMazeStream } from \"../generator\";\nimport { Maze } from \"../generator/types\";\n\ntype MazeOptions = {\n  width: number,\n  height: number,\n  animated: boolean,\n  timeout: number\n};\n\nconst useMaze = ({\n  width, height,\n  animated, timeout\n} : MazeOptions): [ Maze | undefined, boolean ] => {\n  const [ maze, setMaze ] = useState<Maze | undefined>(undefined);\n  const [ done, setDone ] = useState(false);\n\n  useEffect(() => {\n    return generateMazeStream({\n      width, height, timeout,\n      callback: (m, d) => {\n        setMaze(m);\n        setDone(d);\n      }\n    });\n  }, [width, height, animated, timeout]);\n\n  return [ maze, done ];\n};\n\nexport default useMaze;","import React from 'react';\nimport { Cell as CellType, locations } from '../generator/types';\n\ntype CellProps = {\n  cell: CellType,\n  cellWidth: number,\n  cellHeight: number,\n  isCurrent: boolean\n};\n\nconst x = (cell: CellType) => cell.y;\nconst y = (cell: CellType) => cell.x;\nconst incx = (cell: CellType) => cell.y + 1;\nconst incy = (cell: CellType) => cell.x + 1;\n\nconst cellCoords = {\n  top: { x1: x, y1: y, x2: incx, y2: y },\n  right: { x1: incx, y1: y, x2: incx, y2: incy },\n  bottom: { x1: x, y1: incy, x2: incx, y2: incy },\n  left: { x1: x, y1: y, x2: x, y2: incy }\n};\n\nconst cellLines = ({ cell, cellWidth, cellHeight }: CellProps) =>\n  locations\n    .filter(location => cell.walls[location])\n    .map(location =>\n      Object.entries(cellCoords[location])\n        .reduce(\n          (acc, [key, fn]) => ({\n            ...acc,\n            [key]: fn(cell) * (key.startsWith('x') ? cellWidth : cellHeight)\n          }),\n          { key: location }\n        )\n    )\n    .map(coords => (\n      <line\n        {...coords}\n        stroke=\"black\"\n        strokeWidth=\"1\"\n      />\n    ));\n\nconst Cell: React.FC<CellProps> = props => (\n  <g>\n    {!props.cell.visited && (\n      <rect\n        x={props.cell.y * props.cellWidth}\n        y={props.cell.x * props.cellHeight}\n        width={props.cellWidth}\n        height={props.cellHeight}\n        fill={props.isCurrent ? 'red' : '#eee'}\n      />\n    )}\n\n    {props.isCurrent && (\n      <rect\n        x={props.cell.y * props.cellWidth}\n        y={props.cell.x * props.cellHeight}\n        width={props.cellWidth}\n        height={props.cellHeight}\n        fill='red'\n      />\n    )}\n    \n    {cellLines(props)}\n  </g>\n);\n\nexport default Cell;","import React from 'react';\nimport useMaze from '../hooks/useMaze';\nimport Cell from './Cell';\nimport { isCurrent } from '../generator/helpers';\n\ntype Props = {\n  width?: number,\n  height?: number,\n  cellWidth?: number,\n  cellHeight?: number\n};\n\nconst Maze: React.FC<Props> = ({\n  width = 300,\n  height = 300,\n  cellWidth = 20,\n  cellHeight = 20\n}) => {\n  const [ maze, done ] = useMaze({\n    width: Math.floor(width / cellWidth),\n    height: Math.floor(height / cellHeight),\n    timeout: 100, animated: true\n  });\n\n  return (\n    <svg width={width} height={height}>\n      {maze && maze.cells.map(cell => (\n        <Cell\n          cell={cell}\n          isCurrent={!done && isCurrent(cell)(maze)}\n          cellWidth={cellWidth}\n          cellHeight={cellHeight}\n          key={`cell-${cell.x}-${cell.y}`}\n        />\n      ))}\n    </svg>\n  )\n};\n\nexport default Maze;\n","import React from 'react';\nimport Maze from './Maze';\n\nconst App: React.FC = () => (\n  <Maze />\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}